<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hugo Profile</title>
    <link>https://teduandy.github.io/blog/</link>
    <description>Recent content on Hugo Profile</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 22 Jul 2022 08:35:32 +0000</lastBuildDate><atom:link href="https://teduandy.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>hexo-部屬靜態頁面到-github</title>
      <link>https://teduandy.github.io/blog/blogs/hexo-deploy-github/</link>
      <pubDate>Fri, 22 Jul 2022 08:35:32 +0000</pubDate>
      
      <guid>https://teduandy.github.io/blog/blogs/hexo-deploy-github/</guid>
      <description>GitHub 產生站點專案 1. 先點 Github 官網跟著圖片點 第一步 點擊 repositories 第二步 點new 產生站點專案 第三步 在橘色文字那邊輸入 你的用戶名 + github.io 然後按 create repository 第四步 點擊 Your repositories 點選 剛創建的專案 點選 code 會得到 部屬會用到網址 hexo 專案 設置部分 1. hexo 部屬前需安裝的套件 npm install hexo-deployer-git --save 2. 修改根目錄的_config.yml檔案 # Deployment ## Docs: https://hexo.io/docs/one-command-deployment deploy: type: &amp;#34;git&amp;#34; // 類別請寫 git repo: https://github.com/username/username.github.io.git // github專案位置 branch: master // 上傳到此專案的哪一個分支，通常都是 master 3. 輸入指令部屬上傳 每次部屬請進行三步驟 hexo clean // 清除之前建立的靜態檔案 hexo generate // 建立靜態頁面 hexo deploy // 部署至 GitHub </description>
    </item>
    
    <item>
      <title>VUE3 柱狀圖實現</title>
      <link>https://teduandy.github.io/blog/blogs/vue-diagram-use/</link>
      <pubDate>Thu, 21 Jul 2022 15:13:32 +0000</pubDate>
      
      <guid>https://teduandy.github.io/blog/blogs/vue-diagram-use/</guid>
      <description>說明： 需要實現一些 數據上的顯示 網路上有許多框架，但是 HIHHCHARTS 框架較為方便設定
操作方法： 1. 先在 VUE 專案裡面輸入指令安裝 npm i --save vue3-highcharts 2. 這邊不採用全域引入，使用需要再引入的方式 template 設定
&amp;lt;div class=&amp;#34;col-md-8&amp;#34;&amp;gt; &amp;lt;vue-highcharts type=&amp;#34;chart&amp;#34; &amp;lt;!-- 型態 --&amp;gt; :options=&amp;#34;chartOptions&amp;#34; &amp;lt;!-- 要綁入的參數都寫在這邊 --&amp;gt; :redrawOnUpdate=&amp;#34;true&amp;#34; :oneToOneUpdate=&amp;#34;false&amp;#34; :animateOnUpdate=&amp;#34;true&amp;#34; style=&amp;#34;width: auto&amp;#34; &amp;lt;!-- 為了讓整體填充滿整個 div --&amp;gt; /&amp;gt; &amp;lt;/div&amp;gt; script setp lang=”ts” 設定
import VueHighcharts from &amp;#34;vue3-highcharts&amp;#34;; // 分批引入使用 // 每一個 data 的 數據 const seriesData = ref([40, 50, 45, 45, 50, 45]); // 每一個 X 的 數據 const categories = ref([ &amp;#34;Python&amp;#34;, &amp;#34;JavaScript&amp;#34;, &amp;#34;C#&amp;#34;, &amp;#34;VUE&amp;#34;, &amp;#34;Asp.</description>
    </item>
    
    <item>
      <title>axios-mock-adapter為axios提供測試用的假資料</title>
      <link>https://teduandy.github.io/blog/blogs/vue-axios-mock-adapter/</link>
      <pubDate>Thu, 21 Jul 2022 15:01:51 +0000</pubDate>
      
      <guid>https://teduandy.github.io/blog/blogs/vue-axios-mock-adapter/</guid>
      <description>安裝指令: npm install axios-mock-adapter --save-dev 說明: 開發時期或是要做Unit testing需要用假資料來取代server api直接回傳。
import axios from &amp;#39;axios&amp;#39; import MockAdapter from &amp;#39;axios-mock-adapter&amp;#39; let mock = new MockAdapter(axios) mock.onGet(&amp;#39;/users&amp;#39;).reply(200, { users: [ { id: 1, name: &amp;#39;John Smith&amp;#39; }, { id: 2, name: &amp;#39;John Doe&amp;#39; } ] }) axios.get(&amp;#39;/users&amp;#39;) .then(response =&amp;gt; { console.log(response.data) }) 使用方法: 創建uri跟假資料的對應很簡單, 基本上也就是’on&amp;rsquo;‘Method’, 比如說onGet, onPost, 另外還有一個onAny可以處理所有的HTTP methods 做過mock後, axios呼叫這個uri所拿回來的資料通通就都會是假資料了, 這樣也不用為了塞假資料開發測試而去改動自己的程式</description>
    </item>
    
    <item>
      <title>VUE 基礎理論</title>
      <link>https://teduandy.github.io/blog/blogs/vue-basic-theory/</link>
      <pubDate>Thu, 21 Jul 2022 14:40:49 +0000</pubDate>
      
      <guid>https://teduandy.github.io/blog/blogs/vue-basic-theory/</guid>
      <description>1. Vue的双向数据绑定原理: Vue是采用数据劫持结合发布订阅模式，通过Object.defineProperty()来劫持各个属性的getter,setter, 在数据变动时发布消息给订阅者，触发相应的回调函数，从而实现数据双向绑定。
2. SPA 单页面的理解，它的优缺点分别是什么？ SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。 一旦页面加载完成， SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。
優點： 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染 基于上面一点，SPA 相对对服务器压力小 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理 缺點： 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理 SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。 3、v-show 与 v-if 有什么区别？ V-if 是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建； 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 “display” 属性进行切换。 所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景； v-show 则适用于需要非常频繁切换条件的场景。 4、谈谈你对 Vue 生命周期的理解？ beforeCreate 组件实例被创建之初，组件的属性生效之前 created 组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用 beforeMount 在挂载开始之前被调用：相关的 render 函数首次被调用 mounted el 被新创建的 vm.</description>
    </item>
    
    <item>
      <title>VUE3 語法糖</title>
      <link>https://teduandy.github.io/blog/blogs/vue-setup-syntax-sugar/</link>
      <pubDate>Thu, 21 Jul 2022 14:16:42 +0000</pubDate>
      
      <guid>https://teduandy.github.io/blog/blogs/vue-setup-syntax-sugar/</guid>
      <description>1. Vue3 的一大特性函数 &amp;mdash;- setup 說明: setup函数是 Composition API（组合API）的入口 2. data 輸出到 Template 採用兩種函數 1. ref函数 (使用常量居多)
ref 是一个函数，它接受一个参数，返回的就是一个神奇的 响应式对象 。我们初始化的这个 0 作为参数包裹到这个对象中去 ，在未来可以检测到改变并作出对应的相应
&amp;lt;script setup lang=&amp;#34;ts&amp;#34;&amp;gt; const name = ref(&amp;#34;123&amp;#34;) &amp;lt;/script&amp;gt; 2. reactive函数 (使用物件為主) 使用 ref 还是 reactive 可以选择这样的准则 第一，就像刚才的原生 javascript 的代码一样，像你平常写普通的 js 代码选择原始类型和对象类型一样来选&amp;gt; 择是使用 ref 还是 reactive。
第二，所有场景都使用 reactive，但是要记得使用 toRefs 保证 reactive 对象属性保持响应性。
&amp;lt;script setup lang=&amp;#34;ts&amp;#34;&amp;gt; const name = reactive({ name:&amp;#34;123&amp;#34;, age:20 }) &amp;lt;/script&amp;gt; 3. 生命週期鉤子 vue2 跟 vue3 對應 vue2 vue3 beforeCreate created beforeMount onBeforeMount mounted onMounted beforeUpdate onBeforeUpdate updated onUpdated beforeUnmount onBeforeUnmount unmounted onUnmounted errorCaptured onErrorCaptured renderTracked onRenderTracked renderTriggered onRenderTriggered activated onActivated deactivated onDeactivated &amp;lt;script setup lang=&amp;#34;ts&amp;#34;&amp;gt; onMounted(() =&amp;gt; { console.</description>
    </item>
    
    <item>
      <title>VUE axios 重新包裝</title>
      <link>https://teduandy.github.io/blog/blogs/vue-axios-repackage/</link>
      <pubDate>Thu, 21 Jul 2022 14:09:01 +0000</pubDate>
      
      <guid>https://teduandy.github.io/blog/blogs/vue-axios-repackage/</guid>
      <description>說明: 一般使用 axios 是 直接 import 引入 雖然 後端路由 可以透過 配置 重新命名處理掉一長串的網址
但是 如果遇到了 根目錄位置不對的時候 還是要在重新命名的路由在加上之後的位置, 等於說 有使用到 axios 的都要改
這邊 VUE 有提供 二次包裝 可以在 axios 被呼叫之前 增加裡面的配置 在被呼叫出來。
使用方法(先建立一個 js 檔案 並且加入以下): // 先引入 原本安裝的 axios import axios from &amp;#34;axios&amp;#34;; // 這邊設定 產生時 自帶的 url設定(baseURL), 設定頭部則是(headers) const request = axios.create({ baseURL: &amp;#39;/ORD/ORDW1030&amp;#39;, headers: { &amp;#39;Content-Type&amp;#39;: &amp;#39;application/json&amp;#39; }, }) // 這邊是輸出這個設定好的 axios (別的地方引入時輸出甚麼東西給對方使用) export default request 別人引入使用: import 自己重新命名 from 設定的 js檔案 </description>
    </item>
    
    <item>
      <title>VUE build 打包輸出修改位置</title>
      <link>https://teduandy.github.io/blog/blogs/vue-build-set-out-dir-path/</link>
      <pubDate>Thu, 21 Jul 2022 14:03:30 +0000</pubDate>
      
      <guid>https://teduandy.github.io/blog/blogs/vue-build-set-out-dir-path/</guid>
      <description>說明: 輸出時 打包位置 改去別的地方 使用方法: 在 vite.config.js 配置文件裡面 的 export default defineConfig 添加這段 build:{outDir: &amp;lsquo;輸出的位置路徑&amp;rsquo;}, 打包時位置便會到輸入的路徑裡面 { build:{outDir: &amp;#39;../covid-19/covid-19/wwwRoot/app&amp;#39;}, // 配合輸出到 asp.net core 的 wwwRoot資料下底下 plugins: [vue()], } </description>
    </item>
    
    <item>
      <title>VUE 前端與後端交互 cors \ 上線時 根目錄修改方式</title>
      <link>https://teduandy.github.io/blog/blogs/vue-cors-set/</link>
      <pubDate>Thu, 21 Jul 2022 11:39:35 +0000</pubDate>
      
      <guid>https://teduandy.github.io/blog/blogs/vue-cors-set/</guid>
      <description>1. CORS: 說明: 在以往前後端分離時 不同域名 或者 同域名但是不同PORT號 都會遇上 cors 跨域的問題, 一般都會在 後端 設定 cors 允許那些域名是可以進行訪問的,
但是前端設置時必須一個一個針對有寫到 ajax 的部分 url 修改, 上線時域名也會不同 , 這時候還是要在修改一次, 相當麻煩, vue 這邊 提供前端設定
cors 的方法, 並且可以針對後端的 url 取匿名 ,簡短對 ajax 使用時要填上完整的 url, 如果遇到 後端 域名換了只要修改配置文件那邊寫的後端url就
可以修改全部有 ajax 有寫到url 的地方.
使用方法: 在 vite.config.js 配置文件裡面 的 export default defineConfig 添加這段 便可以使用 . (/api 這寫法 路由會自帶 api , 不用的話用 rewrite 處理) server: { proxy: { &amp;#39;/api&amp;#39;: { target: &amp;#39;https://localhost:7181/&amp;#39;, changeOrigin: true, rewrite: (path) =&amp;gt; path.</description>
    </item>
    
    <item>
      <title>C# 將資料輸出成 excel 方法</title>
      <link>https://teduandy.github.io/blog/blogs/c-excel-out/</link>
      <pubDate>Thu, 21 Jul 2022 09:35:18 +0000</pubDate>
      
      <guid>https://teduandy.github.io/blog/blogs/c-excel-out/</guid>
      <description>使用到的套件 using Excel = Microsoft.Office.Interop.Excel; 操作方法 1. 設定需要用到變數 // 設定需要用到的變數 Excel.Application excelApp; // execl 使用的應用程式 變數 Excel._Workbook wBook;	// 活頁簿 變數 Excel._Worksheet wSheet1; // sheet 變數1 Excel._Worksheet wSheet2; // sheet 變數2 Excel.Range wRange; // 活頁簿欄位範圍裏面的控制 及 操作 變數 2. 創建新的 excel 應用 // 開啟一個新的應用程式 excelApp = new Excel.Application(); // 讓Excel文件可見 excelApp.Visible = false; // 停用警告訊息 excelApp.DisplayAlerts = false; // 加入新的活頁簿 excelApp.Workbooks.Add(Type.Missing); // 引用第一個活頁簿 wBook = excelApp.Workbooks[1]; // 基本創建第一個活頁簿時 就有一個 sheet工作表 這邊是添加第二個 wBook.</description>
    </item>
    
    <item>
      <title>Hexo 分類設定</title>
      <link>https://teduandy.github.io/blog/blogs/hexo-category-set/</link>
      <pubDate>Tue, 19 Jul 2022 16:08:18 +0000</pubDate>
      
      <guid>https://teduandy.github.io/blog/blogs/hexo-category-set/</guid>
      <description>如何使用categories進行分類 1. 第一步驟先到bash下指令新增分類 hexo new page category 2. 會發現 主目錄的 source資料夾底下多了一個 category資料夾，點開裡面的 index.md title: 分類 // 類別頁面的標題 date: 2022-07-15 11:35:52 type: category // 型態可以自己取 layout: &amp;#34;category&amp;#34; // 版面呈現 用於 你在使用的樣式專案 3. 接下來到需要分類的 md文檔 進行設定 title: 文檔標題名稱 date: 時間 category: Hexo // 這個 category 是你在 type 設置的名字 用來判別是用於分類，後面的 Hexo 則是 你分類頁面 會顯示有一個分類區塊叫做 Hexo ，文檔裡面設置是這個名字的都會被歸類在Hexo底下。 接下是切換到樣式專案裡面的 _config.yml 裡面設置 找尋 nav 或者 menu 的設置，把 nav: # Resume: Posts: /archives # category: /category // 把#字號刪除 就打開了 設置好後，在啟動伺服器時要先清除舊的靜態資源，然後生成新的靜態支援後再啟動 hexo clean // 先把原來的靜態資源清空 hexo generate // 再重新生成新的靜態資源 hexo server // 再執行 模擬伺服器，這對之後做分類頁面很重要 </description>
    </item>
    
    <item>
      <title>Hexo 安裝 及 設置</title>
      <link>https://teduandy.github.io/blog/blogs/hexo-install-and-setup/</link>
      <pubDate>Tue, 19 Jul 2022 15:01:23 +0000</pubDate>
      
      <guid>https://teduandy.github.io/blog/blogs/hexo-install-and-setup/</guid>
      <description>1.安裝 Hexo （電腦必須先安裝 git 和 node.js） npm install -g hexo-cli 2.建立 Hexo 專案 1.產生一個叫做 blog 的資料夾，資料夾名稱可以任意更改，必須是英文 hexo init blog 2.切換到創建的blog專案裡面，並且用npm安裝hexo必需的套件 cd blog npm install 3.輸入底下指令在本地端開啟測試伺服器，預設 port 號 是 4000 ， 在網址輸入：http://localhost:4000/ 即可預設網頁 hexo server 3.Hexo 設定 Hexo 專案結構 ├── source // markdown檔案放置位置 | ├── _drafts | └── _posts ├── _config.yml // 參數設置 ├── package.json // node_modules 須安裝的東西 ├── scaffolds └── themes // 下載樣式存放位置 4.Hexo 樣式下載 及 設定 1. 樣式下載可以到 Hexo官網 樣式下載這邊找，然後點選樣式進入樣式裡面的 gtihub，下載樣式的專案 放到 自己專案 themes資料夾 底下 ├── _config.</description>
    </item>
    
    <item>
      <title>Hexo 基本指令</title>
      <link>https://teduandy.github.io/blog/blogs/hexo-basic/</link>
      <pubDate>Tue, 19 Jul 2022 14:57:47 +0000</pubDate>
      
      <guid>https://teduandy.github.io/blog/blogs/hexo-basic/</guid>
      <description>快速開始 創建新的筆記 hexo new &amp;#34;My New Post&amp;#34; More info: Writing
啟動模擬伺服器 hexo server More info: Server
生成靜態文件 hexo generate More info: Generating
部屬 hexo deploy More info: Deployment</description>
    </item>
    
    <item>
      <title>GIT 常用指令</title>
      <link>https://teduandy.github.io/blog/blogs/git-common-command/</link>
      <pubDate>Tue, 19 Jul 2022 09:03:25 +0000</pubDate>
      
      <guid>https://teduandy.github.io/blog/blogs/git-common-command/</guid>
      <description>常用指令 建立新的本地端 Repository。 git init 複製遠端的 Repository 檔案到本地端。 git clone [Repository URL] 檢查本地端檔案異動狀態。 git status 將指定的檔案（或資料夾）加入版本控制。用 git add . 可加入全部。 git add [檔案或資料夾] 提交（commit）目前的異動。 git commit 提交（commit）目前的異動並透過 -m 參數設定摘要說明文字。 git commit -m &amp;#34;提交說明內容&amp;#34; 獲取目前工作目錄的 dirty state，並保存到一個未完成變更的 stack，以方便隨時回復至當初的 state。 git stash 查看先前的 commit 記錄。 git log 將本地端 Repository 的 commit 發佈到遠端。 git push 發佈至遠端指定的分支（Branch） git push origin [BRANCH_NAME] 查看分支。 git branch 建立分支。 git branch [BRANCH_NAME] 取出指定的分支。 git checkout [BRANCH_NAME] 建立並跳到該分支。 git checkout -b [BRANCH_NAME] 強制刪除指定分支（須先切換至其他分支再做刪除）。 git branch -D [BRANCH_NAME] 強制恢復到指定的 commit（透過 Hash 值）。 git reset --hard [HASH] 切換到指定的 commit（與 git checkout [BRANCH_NAME] 相同)。 git checkout [HASH] 修改分支名稱。 git branch -m &amp;lt;OLD_BRANCH_NAME&amp;gt; &amp;lt;NEW_BRANCH_NAME&amp;gt; </description>
    </item>
    
    <item>
      <title>SQL 常用語法</title>
      <link>https://teduandy.github.io/blog/blogs/sql-often-use/</link>
      <pubDate>Mon, 18 Jul 2022 16:54:51 +0000</pubDate>
      
      <guid>https://teduandy.github.io/blog/blogs/sql-often-use/</guid>
      <description>讀取資料 SELECT *(或者字段名) FROM 表格 WHERE 條件 AND 條件 SELECT *(或者字段名) FROM 表格 WHERE 條件 OR 條件 插入資料(單一) INSERT INTO 表名(字段名, 字段名 ) VALUES (插入的值, 插入的值) 插入資料(單一) INSERT INTO 表名(字段名, 字段名 ) VALUES (插入的值, 插入的值) 插入多筆資料 INSERT INTO 新表名(字段名1, 字段名2, … ) SELECT 字段名1, 字段名2.. FROM 舊表明 更新語句 UPDATE 表名 SET 字段名=&amp;#34;&amp;#34; WHERE 條件 刪除語句(表內的某一條) DELETE FROM 表名 WHERE 條件 刪除 表 DROP table 表名 刪除 資料庫 DROP database 資料庫名 創建資料庫 CREATE DATABASE 資料庫名字 CHARACTER SET utf8 創建表 CREATE TABLE 表名 (欄位名字 欄位型態 not null, 欄位名字 欄位型態, PRIMARY KEY(欄位名字)) 函數使用(運算類) AVG (平均) COUNT (計數) MAX (最大值) MIN (最小值) SUM (總合) example： SELECT &amp;#34;函數名&amp;#34;(&amp;#34;欄位名&amp;#34;) FROM &amp;#34;表格名&amp;#34;; GROUP BY 使用 SELECT Store_Name, SUM(Sales) FROM Store_Information GROUP BY Store_Name; 說明: 針對店名 算出 sales 總和 輸出之後為這樣 Store_Name	SUM(Sales) Los Angeles	1800 San Diego	250 Boston	700 HAVING 使用 #### 說明： HAVING 子句通常是在一個 SQL 句子的最後。 一個含有 HAVING 子句的 SQL 並不一定要包含 GROUP BY 子句。 example： SELECT Store_Name, SUM(Sales) FROM Store_Information GROUP BY Store_Name HAVING SUM(Sales) &amp;gt; 1500; 說明: 找出 營業額總和 大於 1500 的店家 LEFT JOIN 使用 SELECT table_column1, table_column2.</description>
    </item>
    
    <item>
      <title>C# 散亂筆記</title>
      <link>https://teduandy.github.io/blog/blogs/c-scattered-notes/</link>
      <pubDate>Mon, 18 Jul 2022 16:44:47 +0000</pubDate>
      
      <guid>https://teduandy.github.io/blog/blogs/c-scattered-notes/</guid>
      <description> Process 呼叫EXE 檔案 並 傳值 // 第二個負責傳參數 用 空格 分別不同 值 Process.Start(&amp;#34;C:\\AP06BZ\\EXE\\MTNP200.exe&amp;#34;, &amp;#34;2407 L123370532&amp;#34;); 匿名函數說明 () =&amp;gt; expression // expression = 求值式 本身會有 return value () =&amp;gt; { statement; } // statement = 執行語句，需要 return 才會 return </description>
    </item>
    
    <item>
      <title>C# PrintDocument 元件列印說明 (winform)</title>
      <link>https://teduandy.github.io/blog/blogs/c-winform-printdocument/</link>
      <pubDate>Mon, 18 Jul 2022 16:37:54 +0000</pubDate>
      
      <guid>https://teduandy.github.io/blog/blogs/c-winform-printdocument/</guid>
      <description>說明： 一般來說 用 winform 寫 列印 相當麻煩 因為要對應 位置 以及 以及會使用到多個元件 對此 針對這個部分來做一些說明 使用方法： 1.先在 需要 綁定的按鈕 創建點擊事件，並且在事件裡面 產生一個 PrintDocument 物件 如圖 private void button1_Click(object sender, EventArgs e) { // 創建列印物件 PrintDocument pd = new PrintDocument(); // 並且 加入 啟動列印時 該執行的動作(method)， but 這個方法傳遞參數那邊 必須設置 object sender, PrintPageEventArgs ev 這兩個 pd.PrintPage += new PrintPageEventHandler(this.pd_PrintPage); // 啟動列印 pd.Print(); // 但是在 真正列印的時候 會先預覽 去看 文字或者文字的位置以及大小，才會去做真正的列印，這時候可以先把 print() 先註釋 先使用預覽模式 把 PrintDocument 綁定到 PrintPreviewDialog PrintPreviewDialog pD = new PrintPreviewDialog(); pD.</description>
    </item>
    
    <item>
      <title>C# 資料庫獲取資料</title>
      <link>https://teduandy.github.io/blog/blogs/c-data-get-methods/</link>
      <pubDate>Mon, 18 Jul 2022 16:26:39 +0000</pubDate>
      
      <guid>https://teduandy.github.io/blog/blogs/c-data-get-methods/</guid>
      <description>說明： 方法有兩種，一種是 DataTable 一種是 DataReader，最簡單的就是用 DataTable 接資料 string connString = &amp;#34;server=127.0.0.1;port=3306;user id=root;password=Acuteboy1215;database=mvctest;charset=utf8;&amp;#34;; MySqlConnection conn = new MySqlConnection(); public ActionResult Index() { // 聯繫裡面放入連線字串 conn.ConnectionString = connString; string sql = @&amp;#34; SELECT `id`, `city` FROM `city`&amp;#34;; // 創建新的空的 DataTable 讓抓回來的資料存放 DataTable dt = new DataTable(); // 執行 sql 語句 MySqlDataAdapter adapter = new MySqlDataAdapter(sql, conn); // 將資料注入到 空的 database adapter.Fill(dt); } 在這段程式我們沒有處理 連線 跟 斷線 ， 因為 MySqlDataAdapter 會幫我們處理 </description>
    </item>
    
    <item>
      <title>C# 上傳檔案轉成二進制</title>
      <link>https://teduandy.github.io/blog/blogs/c-fire-change-byte/</link>
      <pubDate>Mon, 18 Jul 2022 16:00:22 +0000</pubDate>
      
      <guid>https://teduandy.github.io/blog/blogs/c-fire-change-byte/</guid>
      <description>一、上傳檔案轉成二進制 try { StreamReader sr = new StreamReader(openFileDialog1.FileName); var bytes = default(byte[]); using (var memstream = new MemoryStream()) { sr.BaseStream.CopyTo(memstream); bytes = memstream.ToArray(); //SetText(sr.ReadToEnd()); } catch(SecurityException ex) { MessageBox.Show($&amp;#34;Security error.\n\nError message: {ex.Message}\n\n&amp;#34; + $&amp;#34;Details:\n\n{ex.StackTrace}&amp;#34;);} } 一. StreamReader sr = new StreamReader(位置路徑); (這邊輸出只是可讀 string 拿不到 byts) 二. var bytes = default(byte[]); 設置空的 bytes 三. var memstream = new MemoryStream() (呼叫一個 空的 不可讀 但可以拿到 byte 檔的容器) 四. sr.BaseStream.CopyTo(memstream); (把可讀的複製到空容器裡面) 五. bytes = memstream.</description>
    </item>
    
    <item>
      <title>C# mysql_conn</title>
      <link>https://teduandy.github.io/blog/blogs/c-mysql-conn/</link>
      <pubDate>Mon, 18 Jul 2022 15:49:56 +0000</pubDate>
      
      <guid>https://teduandy.github.io/blog/blogs/c-mysql-conn/</guid>
      <description>一. 引入 需要的套件 using MySql.Data.MySqlClient; 二. 先有連線字串 string connString = &amp;#34;server=127.0.0.1;port=3306;user id=root;password=***;database=mvctest;charset=utf8;&amp;#34;; 三. 建立一個Connection(聯繫), 連線跟字串連結起來 MySqlConnection conn = new MySqlConnection(); conn.ConnectionString = connString; 四. 連線打開，如果已經開了，再打開一次會出錯，要先判斷 if (conn.State != ConnectionState.Open) { conn.Open(); } 五. 創建 Command(命令) 並且執行 然後判斷成功與否 // sql 字符串 string sql = @&amp;#34;INSERT INTO MTN100 (AREA, CARDNUMBER, SAMFILE) VALUES (&amp;#34;SA&amp;#34;, &amp;#34;0936050029001000000266&amp;#34;, file) // 創建命令 MySqlCommand cmd = new MySqlCommand(sql(sql串), conn(聯繫)); // 執行 int index = cmd.ExecuteNonQuery(); // 判斷成功與否 bool success = false; // 判斷 傳回的 index 是否大於 0 if (index &amp;gt; 0) { success = true; } else { success = false; } ExecuteNonQuery 方法 用在新增修改刪除, 成功返回受影響的列數, 失敗傳回0 六.</description>
    </item>
    
  </channel>
</rss>
